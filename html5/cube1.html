<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"> 
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<script type='text/javascript' src='js/jquery.min.js'></script>
		<input type="file" id="fileinput" />
		<script type="text/javascript">					
			var box = new Array(0);
			var vertex = new Array(0);
			var face = new Array(0);
			var togglex = 0;
			var toggley = 0;
			var togglez = 0;
			var togglew = 1;
			var togglec = 0;
			var scale = 0;
			var translate = 0;
			var fov = 90;
			var d = 1;
			var yoffset;
			var xoffset;
			var cameraZ = 150;
			var cameraX = 400;
			var cameraY = 300;
			var light = "";
			
			function cameraObject(){
				this.x = 400;
				this.y = 300;
				this.z = 150;
			};	
			camera = new cameraObject();			
			
			function lightObject(){
				this.x = 10;
				this.y = 10;
				this.z = 200;
				this.r = 255
				this.g = 0
				this.b = 0;
			};
			
			light = new lightObject();
			
			function faceObject(p1,p2,p3){
				this.p1 = p1;
				this.p2 = p2;
				this.p3 = p3;
				this.behind = 0;
			}
			
			function vertexProjected(x,y,z,xp,yp){
				//serves not other purpose than holding temporary information
				//on the pojection, so that clipping doesnt break the model.
				this.y=y;
				this.z=z;
				this.yp = x;
				this.xp = y;			
			}
			
			function vertexObject(x,y,z){
				this.x=x;
				this.y=y;
				this.z=z;
				this.yp = x;
				this.xp = y;
				this.zoom = 5;
				
				this.rotateZ = function(q){	
					var tmpx = this.x;
					var tmpy = this.y;				
					this.x = tmpx*Math.cos(q) - tmpy*Math.sin(q);
					this.y = tmpx*Math.sin(q) + tmpy*Math.cos(q); 	
					this.fov();					
				}
				
				this.rotateY = function(q){			
					var tmpx = this.x;
					var tmpz = this.z;								
					this.z = tmpz*Math.cos(q) - tmpx*Math.sin(q);
					this.x = tmpz*Math.sin(q) + tmpx*Math.cos(q);	
					this.fov();					
				}			
			
				this.rotateX = function(q){									
					var tmpy = this.y;
					var tmpz = this.z;					
					this.y = tmpy*Math.cos(q) - tmpz*Math.sin(q);
					this.z = tmpy*Math.sin(q) + tmpz*Math.cos(q);	
					this.fov();					
				}	

				this.scaleDown = function(){
					this.x *= 0.99;
					this.y *= 0.99;
					this.z *= 0.99;	
					this.fov();					
				}	
				
				this.scaleUp = function(){
					this.x *= 1.01;
					this.y *= 1.01;
					this.z *= 1.01;		
					this.fov();					
				}	

				this.translate = function(x,y,z){
					this.x += x;
					this.y += y;
					this.z += z;
					this.fov();
				}
				
				this.fov = function(){										
					x0 = this.x - 0;
					y0 = this.y - 0;
					z0 = this.z + camera.z;					

					this.xp = (d*100) * (x0/z0);
					this.yp = (d*100) * (y0/z0);										
				}
			};			
			
			function changelight(){
				x = document.getElementById('lightx').value;
				y = document.getElementById('lighty').value
				z = document.getElementById('lightz').value
				light.x = Math.floor(x);
				light.y = Math.floor(y);
				light.z = Math.floor(z);				
			}
			
			function setup(){					
				vertex[0] = new vertexObject(0.0,0.0,0.0); 
				vertex[1] = new vertexObject(0.0,0.0,1.0); 
				vertex[2] = new vertexObject(0.0,1.0,0.0); 
				vertex[3] = new vertexObject(0.0,1.0,1.0); 
				vertex[4] = new vertexObject(1.0,0.0,0.0); 
				vertex[5] = new vertexObject(1.0,0.0,1.0); 
				vertex[6] = new vertexObject(1.0,1.0,0.0); 
				vertex[7] = new vertexObject(1.0,1.0,1.0); 
				
				face[0] = new faceObject(1,7,5);
				face[1] = new faceObject(1,3,7);
				face[2] = new faceObject(1,4,3);
				face[3] = new faceObject(1,2,4);
				face[4] = new faceObject(3,8,7);
				face[5] = new faceObject(3,4,8);
				face[6] = new faceObject(5,7,8);
				face[7] = new faceObject(5,8,6);
				face[8] = new faceObject(2,6,8);
				face[9] = new faceObject(2,8,4);

				document.getElementById('lightx').value = light.x;
				document.getElementById('lighty').value = light.y;
				document.getElementById('lightz').value = light.z;				
				
				drawloop();
			}
			
			// Calculate The Length Of The Vector			
			function Magnitude(Nx,Ny,Nz){
				return Math.sqrt(Nx*Nx + Ny*Ny + Nz*Nz);
			}		

			function DotProduct(V1x,V1y,V1z,V2x,V2y,V2z){
				return V1x*V2x + V1y*V2y + V1z*V2z;
			}		
			
			function getNormal(Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz){	
				var val = new Array(3);			
				ANx = Cx - Bx;
				ANy = Cy - By;
				ANz = Cz - Bz;
				BNx = Bx - Ax;
				BNy = By - Ay;
				BNz = Bz - Az;
				//? passer det her, kig på det senere
				
				Nx = (ANy * BNz) - (ANz * BNy)
				Ny = (ANz * BNx) - (ANx * BNz)
				Nz = (ANx * BNy) - (ANy * BNx)
				/*
				Nx = ANx * BNy;
				Ny = ANy * BNz;
				Nz = ANz * BNx;
				*/
				magnitudeN = Magnitude(Nx,Ny,Nz);
				
				if(magnitudeN != 0){
					Nx = Nx/magnitudeN;
					Ny = Ny/magnitudeN;
					Nz = Nz/magnitudeN;				
				}				
				val[0] = Nx;
				val[1] = Ny;
				val[2] = Nz;
				return val;
			}

			function returnColor(outx,outy,outz){
				var N;	
				var angle = 0;
				var val = new Array(3);
				
				pX = light.x + 395;
				pY = light.y + 295;				
				pZ = light.z + 100;
				//? passer det her, kig på det senere
				Lx = Math.floor((light.y*pZ) - (light.z*pY));// Cross Product For Y - Z
				Ly = Math.floor((light.z*pX) - (light.x*pZ));// Cross Product For X - Z
				Lz = Math.floor((light.x*pY) - (light.y*pX));// Cross Product For X - Y	
				
				/*
				Lx = light.x * pY;
				Ly = light.y * pZ;
				Lz = light.z * pX;
				*/
				magnitudeL = Magnitude(Lx,Ly,Lz);				
								
				Lx = Lx/magnitudeL;
				Ly = Ly/magnitudeL;
				Lz = Lz/magnitudeL;
				
				N = DotProduct(outx,outy,outz,Lx,Ly,Lz)				
				angle = Math.acos(-1*N)*(180/Math.PI);
				
				val[0] = Math.floor((angle/180) * light.r);
				val[1] = Math.floor((angle/180) * light.g);
				val[2] = Math.floor((angle/180) * light.b);
				
				return val;
			}
			
			function determineBehind(){
				for(i = 0; i <= face.length-1; i++){
					
				}
			}
			
			function drawFaces(viewfield,xoffset,yoffset){
				var tmp = new Array();
				var color = new Array();
				var beginofface = 1;
				var begini = 0;	
				
				for(i = 0; i <= face.length-1; i++){		
					tmp = getNormal(vertex[(face[i].p1)-1].x,vertex[(face[i].p1)-1].y,vertex[(face[i].p1)-1].z,vertex[(face[i].p2)-1].x,vertex[(face[i].p2)-1].y,vertex[(face[i].p2)-1].z,vertex[(face[i].p3)-1].x,vertex[(face[i].p3)-1].y,vertex[(face[i].p3)-1].z);														
					color = returnColor(tmp[0],tmp[1],tmp[2]/*,vertex[(face[i].p1)-1].x,vertex[(face[i].p1)-1].y,vertex[(face[i].p1)-1].z*/);				
					viewfield.beginPath();
						zNormal = ((vertex[(face[i].p2)-1].xp - vertex[(face[i].p1)-1].xp) * (vertex[(face[i].p1)-1].yp - vertex[(face[i].p3)-1].yp)) - ((vertex[(face[i].p2)-1].yp - vertex[(face[i].p1)-1].yp) * (vertex[(face[i].p1)-1].xp - vertex[(face[i].p3)-1].xp));
						if(zNormal > 0 || togglec){	
							viewfield.moveTo(vertex[(face[i].p1)-1].xp+xoffset,vertex[(face[i].p1)-1].yp+yoffset);		
							viewfield.lineTo(vertex[(face[i].p2)-1].xp+xoffset,vertex[(face[i].p2)-1].yp+yoffset);
							viewfield.lineTo(vertex[(face[i].p3)-1].xp+xoffset,vertex[(face[i].p3)-1].yp+yoffset);
							viewfield.lineTo(vertex[(face[i].p1)-1].xp+xoffset,vertex[(face[i].p1)-1].yp+yoffset);								
							viewfield.lineWidth = 1;													
							viewfield.fillStyle = 'rgb('+color[0]+','+color[1]+','+color[2]+')';							
							viewfield.strokeStyle = 'rgb('+color[0]+','+color[1]+','+color[2]+')';							
						}
						if(togglew){
							viewfield.fill();
						}							
						viewfield.stroke();
					viewfield.closePath();
				}				
			}
			

			function drawloop(){				
				var c = document.getElementById("playfield");
				c.width = c.width;			
				var ctx=document.getElementById("playfield").getContext("2d");
				
				var zangle = 0;
				var xangle = 0;
				var yangle = 0;
				var focal_length = 45;
				
				zangle += 0.08;
				xangle += 0.08;
				yangle += 0.08;
				xoffset = c.width/2;
				yoffset = c.height/2;
				
				for(i = 0;i<=vertex.length-1;i++){
					if(scale == 1){
						vertex[i].scaleUp();
					}
					if(scale == 2){
						vertex[i].scaleDown();
					}
					if(translate == 1){
						vertex[i].translate(5,0,0);
					}
					if(translate == 2){
						vertex[i].translate(-5,0,0);
					}	
					if(translate == 3){
						vertex[i].translate(0,5,0);
					}
					if(translate == 4){
						vertex[i].translate(0,-5,0);
					}						
					if(fov == 1){
						vertex[i].zoom += 1;
					}
					if(fov == 2){
						vertex[i].zoom += -1;
					}
					
					if(togglez)
						vertex[i].rotateZ(zangle);
					if(togglex)	
						vertex[i].rotateX(zangle);
					if(toggley)	
						vertex[i].rotateY(zangle);
					
					if(i >= vertex.length-1){
						scale = 0;
						translate = 0;
						fov = 0;
					}
				}
				drawFaces(ctx,xoffset,yoffset);			
				
				ctx.fillStyle = "#ffffff";
				ctx.beginPath();
				ctx.arc(light.x,light.y,2,0,Math.PI*2,true);
				ctx.fill();					
				setTimeout("drawloop()", 40);
			}	

			window.onkeydown = function(event){
				switch(event.which){
					case 37:
						translate = 2;
					break;
					case 38:
						translate = 4
					break;
					case 39:
						translate = 1;
					break;
					case 40:
						translate = 3;
					break;					
					case 65:
						d++;
					break;
					case 67:
						if(togglec){
							togglec = 0;
						} else {
							togglec = 1;
						}										
					break;
					case 77:
						camera.z -= 10;
					break;					
					case 78:
						camera.z += 10;
					break;
					case 83:
						d--;
					break;
					case 87:
						if(togglew){
							togglew = 0;
						} else {
							togglew = 1;
						}						
					break;
					case 88:
						if(togglex){
							togglex = 0;
						} else {
							togglex = 1;
						}					
					break;
					case 89:
						if(toggley){
							toggley = 0;
						} else {
							toggley = 1;
						}					
					break;
					case 90:
						if(togglez){
							togglez = 0;
						} else {
							togglez = 1;
						}
					break;
					case 107:
						scale = 1;
					break;
					case 109:
						scale = 2;
					break;
				}			
			}				
		
			function readSingleFile(evt) {
				//Retrieve the first (and only!) File from the FileList object
				var lines = '';
				var singleline = '';
				var f = evt.target.files[0]; 
				var facecounter = 0;
				var vertexcounter = 0;
				vertex = new Array();
				face = new Array();				
				
				if (f) {
					var r = new FileReader();
					r.onload = function(e) { 
						var contents = e.target.result;		
						lines=contents.split("\n");			
						/*alert( "Got the file.\n" 
							+"name: " + f.name + "\n"
							+"type: " + f.type + "\n"
							+"size: " + f.size + " bytes\n"
							+"lines: " + lines.length + "\n"
							+ "starts with: " + contents.substr(1, contents.indexOf(String.fromCharCode(13)))
						);*/
						
						for(i=1;i<=lines.length-1;i++){
							if(lines[i].substr(0,1) == 'v'){	
								singleline = lines[i].split(' ');
								vertex[vertexcounter] = new vertexObject(singleline[1]*20,singleline[2]*20,singleline[3]*20);
								//document.write(' Counter: '+vertexcounter+' V1: '+singleline[1]+' V2: '+singleline[2]+' V3: '+singleline[3]+'<br>');
								vertexcounter++;
							}
							if(lines[i].substr(0,1) == 'f'){
								singleline = lines[i].split(' ');
								face[facecounter] = new faceObject(singleline[1],singleline[2],singleline[3]);
								//document.write(' Counter: '+facecounter+' F1: '+singleline[1]+' F2: '+singleline[2]+' F3: '+singleline[3]+'<br>');
								facecounter++;					
							}
						}	
					}
					r.readAsText(f);
				} else { 
					alert("Failed to load file");
				}
			}
			document.getElementById('fileinput').addEventListener('change', readSingleFile, false);		
		
		
		</script>	
	</head>
	
	<body onload="setup()" bgcolor="#000000">
		<table> 
			<tr>
				<td>
					<canvas id="playfield" width="800" height="600" style="border:1px solid #c3c3c3;cursor:crosshair;background:#000;">
						Your browser does not support the canvas element.
					</canvas>
				</td>
				<td valign="top">
					<span style="color:#fff;">
						Press x, y or z to toggle movement.<br /> 
						+/- to scale the box.<br />
						arrows to move left/right and up/down.<br />
						a/s change perspective.<br />
						n/m move camera closer or away<br />
						c toggle bacfaceculling<br />
						w toggle wireframe<br />
						<a href="cow.obj">Try saving this obj locally and then load it using the top-left loader.</a><br />

						<input type="text" id="xlabel"><br />
						<input type="text" id="ylabel"><br />
						<input type="text" id="clabel"><br />
						<input type="text" id="dlabel"><br />
						Light (x,y,z)<br />
						<input type="text" id="lightx" onkeyup="changelight()"><br />
						<input type="text" id="lighty" onkeyup="changelight()"><br />
						<input type="text" id="lightz" onkeyup="changelight()"><br />						
					</span>					
				</td>
			</tr>
		</table>
	</body>
</html>